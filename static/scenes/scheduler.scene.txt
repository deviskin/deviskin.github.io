если (режим == "запуск") {
  память.классОбработчика = класс {
      текст = нуль;
      далее = истина;

      конструктор(_текст, _далее) {
        текст = _текст;
        далее = _далее;
      }
      обработать() {
        если (далее) {
          память.приложение.следующаяСтраница();
        } иначе {
          память.приложение.предыдущаяСтраница();
        }
      }
    };
  память.строка = класс {
    текст = '';
    цвет = 'black';
    жирный = ложь;
    верхнийРегистр = ложь;

    конструктор() {
    }

    установитьТекст(_текст){
      текст = _текст;
      если (текст.индексДля('{к}') >= 0 || текст.индексДля('{К}') >= 0){
        цвет = '#FF000F';
      } иначе если (текст.индексДля('{з}') >= 0 || текст.индексДля('{З}') >= 0){
        цвет = '#00B05A';
      } иначе если (текст.индексДля('{с}') >= 0 || текст.индексДля('{С}') >= 0){
        цвет = '#005AB0';
      }
      если (текст.индексДля('{ж}') >= 0 || текст.индексДля('{Ж}') >= 0){
        жирный = истина;
      }
      текст = текст.заменитьВсе('\{.\}','');
      вернуть это;
    }

    установитьЦвет(_цвет){
      цвет = _цвет;
      вернуть это;
    }

    установитьЖирный(_жирный){
      жирный = _жирный;
      вернуть это;
    }

    установитьВерхнийРегистр(_верхнийРегистр){
      верхнийРегистр = _верхнийРегистр;
      вернуть это;
    }
  };
  память.текст = класс {
    строки = [];
    цвет = 'black';
    жирный = ложь;
    верхнийРегистр = ложь;

    конструктор() {
    }

    установитьТекст(_текст){
      строки = [];
      разбиение = _текст.разбить("[\/\\\|]|[\r][\n]|[\n]");
      цикл(i = 0; i < разбиение.длина(); ++i){
        строки.добавить(память.строка()
          .установитьТекст(разбиение[i])
        );
      }
    }

    установитьСтроки(_строки){
      строки = _строки;
      вернуть это;
    }

    установитьЦвет(_цвет){
      цвет = _цвет;
      вернуть это;
    }

    установитьЖирный(_жирный){
      жирный = _жирный;
      вернуть это;
    }

    установитьВерхнийРегистр(_верхнийРегистр){
      верхнийРегистр = _верхнийРегистр;
      вернуть это;
    }
  };
  память.день = класс {
    дата      = память.текст().установитьТекст('1/ВТ');
    праздник  = память.текст().установитьТекст('Рождество Христово');
    служба    = память.текст().установитьТекст('Всенощное бдение');
    время     = память.текст().установитьТекст('17.00');
    конструктор(_дата, _праздник, _служба, _время){
      дата      = память.текст().установитьТекст(_дата);
      праздник  = память.текст().установитьТекст(_праздник);
      служба    = память.текст().установитьТекст(_служба);
      время     = память.текст().установитьТекст(_время);
    }
    текст(индекс){
      результат = праздник;
      если (индекс == 0) {
        результат = дата;
      } иначе если (индекс == 1) {
        результат = праздник;
      } иначе если (индекс == 2) {
        результат = служба;
      } иначе {
        результат = время;
      }
      вернуть результат;
    }
  };
  память.конфигурация = класс {
    коэффициентВысотыШрифта = 4/210;
    коэффициентТолщиныОбводки = 1/210/4;
    заголовок = память.текст().установитьТекст('Расписание Богослужений/Январь');
    подвал = память.текст().установитьТекст('deviskin.github.io@2022');
    подвалПромежуточный = память.текст().установитьТекст('...');
    дни = [];
    загрузитьДни(_текст) {
      дни = [];
      текстовыеДни = _текст.разбить("==+");
      заголовок = память.текст().установитьТекст(текстовыеДни.длина()>1?текстовыеДни[1]:'');
      подвал = память.текст().установитьТекст(текстовыеДни.длина()>=1?текстовыеДни[текстовыеДни.длина()-1]:'');
      цикл(i = 2 ; i + 1 < текстовыеДни.длина(); ++i) {
        текстовыйДень = текстовыеДни[i].сократить();
        линии = текстовыйДень.разбить("--+");
        дни.добавить(память.день(
          (линии.длина()>0?линии[0]:'').сократить(),
          (линии.длина()>1?линии[1]:'').сократить(),
          (линии.длина()>2?линии[2]:'').сократить(),
          (линии.длина()>3?линии[3]:'').сократить()));
      }
    }
  }();
  память.классОбратногоОбработчика = класс {
    круг = 0;
    индекс = 0;
    заливки = ['red','yellow','blue','green'];
    d3 = 0;
    i = 0;
    конструктор(_круг,_d3, _i, _индекс) {
      круг = _круг;
      d3 = _d3;
      i = _i;
      индекс = _индекс;
    }
    обработать() {
      круг
        .переход()
        .продолжительность(1000)
        .заливка(заливки[индекс++ % заливки.длина()])
        .позиция(d3.ширина() - (100 + i*20),100 + i*20);
    }
  };
  память.классПриложения = класс {
    d3 = загрузитьПоддержкуD3();
    смещениеДней = 0;
    смещения = [];
    индексСтраницы = индексНачальнойСтраницы;
    следующееСмещение = 0;

    следующаяСтраница(){
      если (индексСтраницы + 1 < смещения.длина()) {
        ++индексСтраницы;
        d3.очиститьВсё();
        выполнить(ложь);
        d3.пересоздать();
      }
    }

    предыдущаяСтраница(){
      если (индексСтраницы > 0) {
        --индексСтраницы;
        d3.очиститьВсё();
        выполнить(ложь);
        d3.пересоздать();
      }
    }

    высотаШрифта() {
      вернуть память.конфигурация.коэффициентВысотыШрифта * ширина();
    }
    толщинаЛиний() {
      вернуть память.конфигурация.коэффициентТолщиныОбводки * ширина();
    }
    ширина() {
      вернуть d3.ширина();
    }
    высота() {
      вернуть d3.высота();
    }
    высотаШрифтаЗаголовка() {
      коэффициентВысотыЗаголовка = 1 / 2 * 3;
      вернуть высотаШрифта()*коэффициентВысотыЗаголовка;
    }
    метрикаТекстаЗаголовка(текст) {
      вернуть d3.метрикаТекста(текст, высотаШрифтаЗаголовка(), ложь);
    }
    высотаШрифтаПодвала() {
      коэффициентВысотыЗаголовка = 1 / 2 * 3;
      вернуть высотаШрифта()*коэффициентВысотыЗаголовка;
    }
    метрикаТекстаПодвала(текст) {
      вернуть d3.метрикаТекста(текст, высотаШрифтаПодвала(), ложь);
    }
    высотаПодвала() {
      метрикаВысоты = метрикаТекстаПодвала('ХХ').высота;
      высотаПодвала = глобально().округлить(метрикаВысоты);
      вернуть высотаПодвала;
    }
    высотаБезПодвала() {
      вернуть d3.высота() - высотаПодвала();
    }
    вывестиПодвал() {
      вертПоз0 = высотаБезПодвала();

      текстНазад = 'НАЗАД';
      метрикаНазад = метрикаТекстаПодвала(текстНазад);

      текстДалее = 'ДАЛЕЕ';
      метрикаДалее = метрикаТекстаПодвала(текстДалее);

      /*d3.прямоугольник()
          .позиция(0, вертПоз0)
          .ширина(метрикаНазад.ширина * 3 / 2)
          .высота(метрикаНазад.высота)
          .скругления(метрикаНазад.высота/2, метрикаНазад.высота/2)
          .заливка('white')
          .контур('black')
          .толщинаКонтура(толщинаЛиний());// */

      если (индексСтраницы > 0) {
        d3.текст()
          .текст(текстНазад)
          .размер(высотаШрифтаПодвала())
          .текстовыйЯкорь('middle')
          .позиция(метрикаНазад.ширина * 3 / 2 / 2, вертПоз0 + высотаШрифтаПодвала())
          .заливка('black')
          .поНажатию(память.классОбработчика, ложь)
          ;
      }

      если (индексСтраницы + 1 < смещения.длина()) {
        d3.текст()
          .текст(текстДалее)
          .размер(высотаШрифтаПодвала())
          .текстовыйЯкорь('middle')
          .позиция(ширина() - (метрикаДалее.ширина * 3 / 2 / 2), вертПоз0 + высотаШрифтаПодвала())
          .заливка('black')
          .поНажатию(память.классОбработчика, истина)
          ;
      }

      текстСтраницы = 'Страница ' + (индексСтраницы + 1) + ' из ' + (смещения.длина());
      d3.текст()
        .текст(текстСтраницы)
        .размер(высотаШрифтаПодвала())
        .текстовыйЯкорь('middle')
        .позиция(ширина()/2, вертПоз0 + высотаШрифтаПодвала())
        .заливка('black');
    }
    вывестиСтроки(всеСтроки, поз, цвет, еслиПомещается, заливатьФон) {
      вертПоз = поз;
      этиСтроки = всеСтроки;
      метрикаВысоты = метрикаТекстаЗаголовка('ХХ').высота;
      высотаЗаголовка = метрикаВысоты * этиСтроки.длина();

      если (еслиПомещается && (вертПоз + высотаЗаголовка > высотаБезПодвала())) {
        вернуть вертПоз;
      }

      если (заливатьФон) {
        d3.прямоугольник()
          .позиция(0, вертПоз)
          .ширина(ширина())
          .высота(высотаЗаголовка)
          .заливка('white')
          .контур('none');
      }

      цикл(k = 0; k < этиСтроки.длина(); ++k){
        строка = этиСтроки[k];
        d3.текст()
          .текст(строка.текст)
          .размер(высотаШрифтаЗаголовка())
          .текстовыйЯкорь('middle')
          .позиция(0 + ширина()/2,
            вертПоз + высотаШрифтаЗаголовка() + метрикаВысоты * k)
          .заливка(строка.цвет);
      }
      вертПоз += высотаЗаголовка;
      вернуть вертПоз;
    }
    расчитатьСтраницы() {
      i = 0;
      вертПоз = 0;
      текущееСледующееСмещение = 0;
      текущееСмещениеДней = 0;
      смещения = [0];

      если (текущееСмещениеДней == 0) {
        вертПоз += память.конфигурация.заголовок.длина() * высотаШрифтаЗаголовка();
      }

      столбцы = [1, 2, 3, 4];
      цикл(i = 0; i < память.конфигурация.дни.длина(); ++i) {
        день = память.конфигурация.дни[i];

        максимальноеКоличествоСтрок = 1;
        цикл(j = 0; j < столбцы.длина(); ++j){
          кс = день.текст(j).длина();
          если (кс > максимальноеКоличествоСтрок) {
            максимальноеКоличествоСтрок = кс;
          }
        }

        высотаТекста = d3.метрикаТекста("ТЕСТ", высотаШрифта(), ложь);
        высотаПрямоугольника = максимальноеКоличествоСтрок * высотаТекста.высота;

        текущееСледующееСмещение = i;
        если (вертПоз + высотаПрямоугольника > высотаБезПодвала()) {
          смещения.добавить(текущееСледующееСмещение);
          вертПоз = 0;
        }

        вертПоз += высотаПрямоугольника;
      }

      вертПозОкончание = вертПоз + память.конфигурация.подвал.длина() * высотаШрифтаЗаголовка() + 2*толщинаЛиний();
      если (вертПозОкончание > высотаБезПодвала()) {
        смещения.добавить(текущееСледующееСмещение+1);
      }

      память.общееКоличествоСтраниц = смещения.длина();
    }
    выполнить(загрузитьРасписание) {
      если (загрузитьРасписание) {
        память.конфигурация.загрузитьДни(сценарии.текстРасписания());
        расчитатьСтраницы();
      }

      смещениеДней = смещения[индексСтраницы];

      d3.прямоугольник()
        .позиция(0, 0)
        .ширина(ширина())
        .высота(высота())
        .заливка('white');

      i = 0;
      вертПоз = 0;

      если (смещениеДней == 0) {
        вертПоз = вывестиСтроки(память.конфигурация.заголовок, вертПоз, 'red', истина, истина);
      }

      ширина1 = d3.метрикаТекста('ХПНХ', высотаШрифта(), ложь).ширина;
      ширина4 = d3.метрикаТекста('Х23.00Х', высотаШрифта(), ложь).ширина;
      ширина2 = (ширина() - ширина1 - ширина4) * 3 / 5;
      ширина3 = (ширина() - ширина1 - ширина4) - ширина2;
      столбцы = [ширина1, ширина2, ширина3, ширина4];

      цикл(i = смещениеДней; i < память.конфигурация.дни.длина(); ++i){
        день = память.конфигурация.дни[i];

        максимальноеКоличествоСтрок = 1;
        цикл(j = 0; j < столбцы.длина(); ++j){
          кс = день.текст(j).длина();
          если (кс > максимальноеКоличествоСтрок) {
            максимальноеКоличествоСтрок = кс;
          }
        }

        высотаТекста = d3.метрикаТекста("ТЕСТ", высотаШрифта(), ложь);
        высотаПрямоугольника = максимальноеКоличествоСтрок * высотаТекста.высота;

        следующееСмещение = i;
        если (вертПоз + высотаПрямоугольника > высотаБезПодвала()) {
          break;
        }

        горПоз = 0;
        скругления = 2*толщинаЛиний();
        цикл(j = 0; j < столбцы.длина(); ++j){
          d3.прямоугольник()
            .позиция(горПоз, вертПоз)
            .ширина(столбцы[j])
            .высота(высотаПрямоугольника)
            .заливка('white')
            .контур('black')
            .толщинаКонтура(толщинаЛиний());
          кс = день.текст(j).длина();
          смещениеВысоты = (максимальноеКоличествоСтрок - кс)/2;
          этиСтроки = день.текст(j);
          цикл(k = 0; k < этиСтроки.длина(); ++k){
            этаСтрока = этиСтроки[k];
            d3.текст()
              .текст(этаСтрока.текст)
              .размер(высотаШрифта())
              .жирный(этаСтрока.жирный)
              .текстовыйЯкорь('middle')
              .позиция(горПоз + столбцы[j]/2,
                вертПоз + высотаШрифта()
                + высотаТекста.высота * (k + смещениеВысоты))
              .заливка(этаСтрока.цвет);
          }
          горПоз += столбцы[j];
        }
        вертПоз += высотаПрямоугольника;
      }

      вертПоз2 = вывестиСтроки(память.конфигурация.подвал, вертПоз + 2*толщинаЛиний(), 'black', истина, истина);

      если (показыватьПодвал) {
        вывестиПодвал();
      }
    }
  };
  память.приложение = память.классПриложения();
}

если (режим == "запуск") {
  память.приложение.выполнить(истина);
} иначе {
  обработчик.обработать();
}
